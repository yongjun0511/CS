### 프로세스란?
- 프로세스란 실행중인 프로그램을 의미한다.

### 프로세스의 문맥 (context)
>프로그램이 태어나서 종료되는 시점까지, 그 중간을 딱 잘라서 봤을 때 어떻게 실행을 했는지? 어디까지 수행을 했는지를
규명하는 요소가 바로 이것이다.

- PC가 어디를 가르키는가? (현재 작업 위치)
- 어디까지 실행 했는지
- 프로그램의 메모리 스택에 어디까지 쌓여있는가
- data의 변수의 값은 얼마인가?
- 현재 cpu의 레지스터에는 어떤값이 들어있는가

>이런 모든 것들 프로세스가 어디까지 실행 되었는지 알기 위한 모든 것들을 프로세스의 문맥이라고 부릅니다.
<img width="609" height="352" alt="스크린샷 2025-08-05 오후 8 10 49" src="https://github.com/user-attachments/assets/15698083-9c11-4dd4-864d-a41172c37c8b" />

### CPU의 수행 상태를 나타내는 하드웨어 문맥

- Program Counter가 어디를 가르키는가?
- 각종 register에 어떤 값들을 가지고 있는가?

### 프로세스 주소공간

- code , data, stack

### 프로세스 관련 커널 자료 구조

- PCB
- 커널 스택

---
### 프로세스의 상태

Running

- CPU를 잡고 Instruction 수행중인 상태를 의미한다.

Ready

- CPU를 기다리는 상태 (른 모든 조건을 완수한 상태)
- 적어도 필요한 정보가 메모리에 올라가 있는 상태

Blocked( wait, sleep )

- CPU를 주어도 Instruction을 수행할 수 없는 상태
- I/O가 만족되지 않아 기다리는 상태
- ex) 디스크에서 파일을 읽어와야 하는 경우

아래 두개는 경우에 따라서 설명

New

- 프로세스가 생성중인 상태

Terminated

- 수행이 끝난 상태 하지만 아직 자료 구조등을 정리 못한 상태
<img width="391" height="195" alt="스크린샷 2025-08-05 오후 8 12 56" src="https://github.com/user-attachments/assets/d64d88b9-5481-4977-bdd9-85df1730876f" />

ex)
<img width="611" height="378" alt="스크린샷 2025-08-05 오후 8 13 24" src="https://github.com/user-attachments/assets/0cc9b10b-335e-492c-a0d7-5693f32affca" />

- 계속 Ready queue에 있다가 IO가 필요한 경우 blocked 상태로 IO 큐로 가고,  끝나면 다시 레디 큐로 돌아온다.
- 공유 데이터도 순서대로 해야한다 안그럼 데이터의 일관성이 없어질 수 있음. 따라서, 공유 데이터 접근 Queue도 있다.
- 큐라는 것을 분리해서 그려놨는데 사실 Queue라는 것은 커널이 데이터 블럭에 자료 구조로 가지고 있음.

--- 
### PCB의 구성
<img width="416" height="240" alt="스크린샷 2025-08-05 오후 8 15 01" src="https://github.com/user-attachments/assets/b7222d0b-fc1c-4f0f-9708-66f41a5ad35b" />

### 문맥 교환 Context Switch

CPU에서 프로세스를 다른 프로세스로 넘겨주는 과정을 의미한다.
- 뺏길때는 문맥을 저장하고 다시 실행할 때에는 문맥을 읽어와야하는 과정을 반복한다.
- 다만 System call이나 Interrurpt 발생시 반드시 Context switch가 발생하는 것은 아님. (조금 더 적은 오버헤드)
- 프로세스가 자체가 바뀌어야 하며, 커널모드로 받았다가 다시 돌려주는 경우 Context Switch가 발생하지 않음.
- timmer interrupt나 IO System call 발생 후 다른 프로세스에게 넘겨주는 경우 Context Switch 발생.

> 물론 커널 모드 넘어가도 약간의 문맥을 PCB에 저장해야 하지만, 프로세스 바뀌는 것보다 훨 씬 오버헤드 적음.
> 문맥 교환을 하는 경우 cache 메모리를 전부 지워버려야 하는데 커널 모드 잠깐 갔다 오는 것은 캐시를 날려버리지는 않는다.

### Process 스케줄링 하기 위한 Queue

Ready Queue, Device Queue는 위에서 언급을 했다.
부수적인 다른 Queue들의 종류.

자원 큐

- 공유데이터를 위한 큐

Job Queue

- 현재 시스템 내의 모든 프로세스 집합.

### 스케줄러 (Scheduler)

Long - term Scheduler ( 장기 스케줄러 or Job 스케줄러)

- 메모리(및 각종 자원)를 어떤 프로세스에게 줄지 결정. ( new → ready 상태로 넘어갈 때 메모리에 올려야 합니다 )
- degree of MultiProgramming을 제어 즉, 메모리에 프로그램이 몇개 올라가는가? 프로세스 수를 제어한다.
- time sharing system에서는 보통 장기 스케줄러가 없음 (무조건 ready)

Short - term Scheduler ( 단기 스케줄러 or CPU 스케줄러)

- 짧은 시간 단위로 millisecond 단위로 수행된다.
- 다음 번에 어떤 프로세스를 running 할지 CPU를 얼만큼 줄지 결정한다.

Medium - term Scheduler ( 중기 스케줄러 or Swapper)

- 현재 시스템들은 이걸 이용한다고 생각하면 된다. 프로세스에게서 memory를 뺏는 문제 degree Of Multiprogramming 제어
- 여유 공간 마련을 위해 프로세스를 통쨰로 메모리에서 디스크로 쫒아내고 스왑 영역에 저장ㅎ나다.
- 특히 봉쇄 상태의 프로세스들은 0순위로 스왑 아웃 됌.

> 이것 때문에 Suspended (stopped)라는 상태가 추가되었다고 보면 된다.
> 외부적 이유로 프로세스의 수행이 정지된 상태 디스크로 통째로 swap out됨.

근데 중기 스케줄러 뿐만 아니라 사용자가 프로그램을 일 시 정지시킨 경우에도 Suspended 상태가 될 수 있다.
이 경우에는 사람이 재생시켜 주어야 함.

(참고)
- block 상태에서 스왑 당하면 suspended block이 되며 
- ready 상태에서 스왑 당하면 suspended ready가 된다.

---
### Thread

프로세스 내부에 CPU 수행 단위가 여러개 있는 경우, 원래 프로세스 마다 각자의 주소공간이 생긴다. (code data stack)
그런데 이것을 하나만 띄워놓고 공유하는게 쓰레드의 개념.

<img width="419" height="245" alt="스크린샷 2025-08-05 오후 8 19 59" src="https://github.com/user-attachments/assets/ac6be68e-4990-4588-8a7d-9a537b5e72f7" />

즉, 프로세스 하나에서 공유하는 것을 최대한 공유하고 상태를 공유하는 개념이며, 별도로 가지고 있는 것은 PC, Register, Stack만 별도로 존재한다.

> 쓰레드의 정의를 정확히 물어본다면 ? -> CPU를 수행하는 단위
쓰레드의 구성
- 프로그램 카운터
- register set
- stack 

쓰레드가 공유하는 부분 (= task라고 부름)
하나의 프로세스에 여러 쓰레드 테스크는 하나
code, data, 그리고 OS 자원들..

쓰레드를 그래서 lightweight process라고 함. 
전통 적인 개념은 heavyweigth process라고 함.

### Benefits Of Thread

- 응답성이 빠르다 
ex) 웹 브라우저 하나의 쓰레드는 뭐 그림 가져오고 나머지는 글 미리 보여줌
비동기랑 느낌이 비슷하다고 함. 비동기식 입출력 이라고 봐도 무방.

- 자원 공유
똑같은 일을 하는 프로세스를 여러개 두면 메모리 자원 낭비

- 효율이 좋다
프로세스 하나를 만드는 것은 오버헤드가 크다.
또한 컨텍스트 스위칭 비용을 줄일 수 있음.

- CPU 여러개 환경에서 
각각의 쓰레드가 병렬적으로 다른 CPU에서 일할 수 있음. 
ex)행렬곱.

### 쓰레드 구현 (간단히)

- 어떤 것은 라이브러리 → 유저 쓰레드
OS는 모르고 운영체제가 스스로 쓰레드를 관리함. 커널이 보기에는 일반적 프로세스로 보인다.
약간의 구현상의 제약점이 존재할 수 있음.

- 어떤 것은 커널에서 지원 → 커널 쓰레드
쓰레드가 많다는 것을 OS에서 알고 있고 스케줄링 하듯이 쓰레드간 넘겨줌

- 리얼 타임을 지원하는 → 리얼 타임 쓰레드
---

### 프로세스의 생성

- 부모 프로세스가 자식 프로세스를 생성한다(복제를 생성한다).
- 프로세스의 트리 (계층 구조)가 족보 형태로 형성이 된다.

프로세스는 자원을 필요로 하고 이것을 OS로 부터 받게 되어있다.

부모와 자원을 공유하는 경우
- 자원의 공유
→ 모든 자원 공유
→ 일부 or 전혀 공유 x

하지만, 원래는 자식은 별도의 프로세스라 자원을 공유하지 않는다.

### 부모와 자식 프로세스
부모와 자식을 공존하며 수행, 자식이 종료될 떄까지 기다리는 모델도 있음.

> 주소 공간 (Address space)

자식은 부모의 공간을 복사한다. PCB나 자원 이런것을 복사하고 복제 생성 이라고 부른다.
그런데 이렇게 완전히 복제만 하면 같은 행위를 하기 때문에, 일단 복제를 해놓고 그 위치에 새로운 프로그램을 덮어쓸 수 있다.

이걸 fork() 라는 시스템 콜이라고 하고 exec() 시스템 콜을 이용해 다른 프로그램으로 덮어쓴다.
1단계 : 복제 → 2단계 :  덮어씌움 을 통해서 탄생.

fork 나 exec()같은 경우는 시스템 콜이니 운영체제에게 부탁해야함

### 프로세스의 종료

- exit이라는 시스템 콜을 실행 해야한다.

보통 자식이 먼저 죽고 부모가 후처리를 하는 구조이다.

자식이 부모에게 output data를 보냄 (wait ←보냄)

부모 프로세스가 자식 수행을 종료 시키는 경우 abort를 사용한다.
1.자식이 자원의 한계치를 넘기거나
2.자식에게 할당된 테스크가 더 이상 필요하지 않는 경우
3.부모가 종료 (exit)하는 경우

자식을 먼저 죽여야 하기 때문에 강제 종료를 하는 것이다.

원래 똑같은 내용을 만든다고 하면 당장 카피할 필요는 사실 없다. 가능한 공유할 수 있는 것들을 공유하고,
원래는 주소공간을 만드는 것이 목적이지만. 리눅스 같은 것들을 PC만 카피해서 같은 곳을 가르키는 방법을 사용한다.

> 근데 stack에 쌓이는 내용이나 data의 변수는 내용이 달라질 수 있다.
이럴 경우 일부를 카피해 와서 가짐 이런 기법을 copy on write(COW)라고 한다.

(참고)
- 자식 프로세스는 fork 이후 부터 실행하게 된다.
- 그 이유는 PC도 다음줄 부터 실행하도록 복사되기 때문이다.
- 근데 fork로 만들어진 복제본은 구분을 해줌 PID를 양수를 얻고 복제본들은 0을 얻음.
- 그래서 서로 다른 일을 시킬 수가 있다.
