> 하드웨어 적인 부분을 설명해주는 Chapter

## Memory

- CPU의 작업 공간이 메모리다.
  CPU는 매 순간 (Clock Cycle)마다 메모리에서 기계어를 읽어와서 실행하게 됩니다.

## IO Device

- 키보드, 모니터, 프린터
- 하드 디스크 (보조 기억 장치)
  데이터를 메모리에 읽기도 하고 처리 결과를 디스크에 저장하기도 함.
- 각각의 IO Device는 device controller라는 작은 CPU를 가지고 있음.
  따라서, 디스크 내부 읽는 등의 작업은 디스크 컨트롤러가 수행한다.
- Device 마다 Memory같이 작업 공간이 필요한데 이걸 Local Buffer 라고 한다.
- CPU에 비해서 매우 매우 느리다.

## CPU

- 내부적으로 Memory보다 빠른 작은 저장 공간 존재 → 레지스터
- mode bit → 지금 CPU에서 실행되는 것이 운영체제인지 사용자 프로그램인지 구분해주는 것. (0: 커널모드, 1:사용자 모드)
- Interrupt line ← 인터셉트가 쌓이는 곳
- IO Device에서 입력된 값들을 바탕으로 처리해야 하는 일들은 나중에 처리함. 당장 처리할 수 있는 것들을 먼저함.

## Timer

- 특정 프로그램이 CPU 독점을 막는 목적의 도구.
- 타이머 값을 설정하고 사용자 프로그램에 CPU를 넘겨주고 타이머 시간이 끝나면 CPU를 뺏김.
- 시간 끝나면 CPU에게 타이머 인터럽트를 건다.
- 타이머 세팅을 하는 걸 load timer 라고 하며 특권 명령이다.

## Mode bit
1 : 사용자 모드
0 : 커널 모드 (모니터 모드) 특권 명령 수행 가능.

mode bit이 0일 때는 메모리 접근 뿐만 아니라 모든 일을 할 수 있도록 처리가 된다.
하지만, 1일 때에는 제한된 Instruction만 수행가능 → 아무나 커널의 기능을 사용하지 못하게 하기 위함이다.

- Interrupt나 Exception 발생시 하드웨어가 mode bit 0으로 바꿈
- 사용자 프로그램에게 CPU 넘겨줄 때 mode bit 1로 세팅

## Device Controller

- IO Device를 전담하는 작은 컨트롤러
- 제어 정보를 위해 Control Register과 status register를 가짐
  제어 정보를 위한 레지스터란 CPU가 여기에 일을 시킬 때 사용되는 레지스터.
- local buffer (일종의 data register)
  디바이스에서 담은 데이터를 CPU로 넘겨주거나 메모리 값을 여기에 담아야 하니까 그런 역할을 한다.

ex) 파일을 저장하라.
명령 → 제어 레지스터로감
파일 → 로컬 버퍼로감

- 메모리도 디바이스 이기 때문에 memory controller가 있음.
- CPU가 하드웨어 이듯이 하드웨어임Device driver는 OS 코드 중 각 장치별 처리 루틴 → 소프트 웨어

근데 이게 Device 동작 코드는 아님 그건 따로 있음.

## DMA Controller

- 너무 많이 CPU가 인터럽트 당해 따라서 직접 Direct 하게 Memory Access 접근 할 수 있는 컨트롤러임.
- IO로 뭐 들어온 정보들을 메모리에 복사해주고 CPU로 인터럽트 한번만 걸어준다 ( 작업을 마쳤습니다 ).
- device의 buffer storage의 내용을 block단위로 옮김.

<img width="548" height="402" alt="스크린샷 2025-07-29 오후 10 37 29" src="https://github.com/user-attachments/assets/43ed0b71-e0bd-440a-b9f4-6a908ee420e1" />

---

## IO 명령

- 모두 특권 명령이다.
- 사용자 프로그램은 그럼 어떻게 특권 명령을 하는가? → OS에게 부탁을 하고 그걸 시스템 콜(System call)이라고 부른다. IO 뿐만 아니라 OS코드를 사용해야 하는 모든 경우 이 방법을 사용한다.

ex)
예를 들어서 메모리에서 코드를 돌림 Main 함수가 있고, 거기서 다른 함수를 호출해도 내부 메모리에서 위치가 바뀔 뿐이다.

그런데 System Call을 하는 것은 메모리 위치 바꾸는 것보다 복잡하다.
예를 들어, IO를 해야 하는 경우 사용자 프로그램은 OS로 메모리 점프가 불가능하다.
→ 프로그램이 직접 Interrupt를 걸어서 CPU를 이용해 제어권을 OS로 넘겨줌.
→ 그런 다음 OS가 명령.

IO명령을 모두 특권 명령으로 함으로써 하드웨어 보안이 성립됨.

## 메모리 보안

- 하드웨어 보안 만큼 메모리 보안도 중요함. 하드웨어 보안은 IO명령을 커널만 수행하도록 함으로써 지켜졌다.
  (다른 사용자 메모리 접근 불가 등등)

- 기준 레지스터 (base register) : 접근 가능 메모리 가장 작은 부분
- 한계 레지스터 (limit register) : 접근 메모리 몇까지 되는지 써있음
  로 메모리 부분을 체크해 합법적인 메모리 부분인지 검사함.

따라서 기준 레지스터 , 기준 레지스터 + 한계 레지스터 만큼 접근 가능 범위가 됨.
근데 이건 연속적인 메모리를 가졌을 경우이고 나중에 페이징에 대해서 자세히 다룰 예정이다.

⚠️ 참고로 커널 모드는 레지드터와 관계없이 모두 접근 가능함.

## Interrupt

- Interrupt (하드웨어 인터럽트) : 일반적 인터럽트 하드웨어가 발생시킨 인터럽트
- Trap(소프트웨어 인터럽트) : Exception, System Call

  Exception 예시 사용자가 프로그램 바깥의 메모리를 참조하려고 하거나 0으로 나누는 등의 비정상 적인 행동.

- 인터럽트 백터 : 각각의 인터럽트 종류마다 해야할 일이 다르다. 이때 처리 루틴의 주소를 가지고 있음.
- 인터럽트 처리 루틴 (Interrupt Service Routine, 인터럽트 핸들러) : 해당 인터럽트를 처리하는 커널 함수.

인터럽트가 발생하면 OS로 CPU 제어권이 이양되어 처리된다.

> 인터럽트 핸들링
→ 인터럽트가 발생했을 경우 처리해야하는 일의 절차 가장 먼저 프로그램의 현재 상태를 먼저 저장한다. (실행 중인 명령의 메모리 주소 등등..)

CPU에서 명령이 실행되는 경우 CPU 내부에 있는 임시 기억 장치인 Register에 데이터를 읽거나 쓰면서 일하는데 다른 명령 처리하면 다 지워지니까 이런 것들을 저장해 두어야 함.

>PCB에 이런것들이 저장됨.

(참고) 원래 인터럽트가 발생하면 다른 인터럽트 발생을 원칙적으로는 안되지만, 우선 순위 높은 인터럽트가 발생하면 먼저처리함.

## CPU는

- 메모리 특정 위치에 있는 기계어를 가져와서 읽어오게 된다.

이때, 레지스터 중에서 Program Counter라고 메모리 주소를 가르키는 레지스터가 있는데 그게 가르키고 있는 메모리 위치에서 instruction을 가져와서 읽어옴.
이게 OS가 존재하는 메모리를 가르키면 커널 모드 아니라면 사용자 모드가 된다.

- 한 줄씩 처리하다가, 한 줄이 끝나면 다음 주소를 가르킴.

보통 Instruction하나는 4byte 그래서 주소가 보통 순차적 실행하니까 주소가 4 증가함. (항상 그런 것은 아니지만..)
Jump Instruction도 있음.

## 동기식 입출력 (synchronous I/O)

- I/O 장치에 요청을 보내고 완료시까지 기다린다. 

구현 방법 1.
- IO가 조금 오래 걸리니 CPU를 낭비시킴

구현 방법 2.
- IO 가 완료될 떄까지 다른 프로그램으로 넘겨줌 이게 끝나고 나면 IO 디바이스가 인터럽트를 걸고… 다시 CPU를 돌려줄 수 있다.
- 근데 IO가 완료될 떄까지 돌려주지 않음… 줘도 못하기 때문이다. 이런 것을  봉쇄 상태 (blocked state)라고 함.

그런데, 이 과정에서 동시성 문제가 발생할 수 있다. 그래서 동기화 시에는 queue로 순서를 보존함.
처리 순서를 바꿀수도 있는데 그러면 동기화 문제 해결을 위한 방안이 필요.

## 비동기식 입출력

- I/O 요청을 던져두고 다른 일을 하러감 (같은 프로세스 내부에서!!).
- 인터럽트를 통해서 요청이 끝난 것을 알게됩니다.

> 읽기 작업의 경우 
>
> 예를 들어서, IO 요청을 했고 결과를 봐야지만 다음 결과를 할 수 있는 경우가 많다.
그런데 필요가 없는 작업을 먼저 하다가 다시 결과가 필요한 작업을 할 수 있다.
> 
> 쓰기 작업의 경우
> 
> 화면 출력 하던가 저장하거나? 이런거는 보통 결과를 꼭 봐야지 다음 일을 할 수 있는 것은 아니니까 비동기로 처리하는 것이 자연스럽다.

## IO를 어떻게 하는가?


방법 1.  일반적인 방식 (Special Instruction)

일반적으로 CPU 기계어(Instruction)에는 메모리 접근 Instruction과 IO Device에  접근하는 Instruction이 있다.

IO를 하는 Special Instruction

방법 2. Memory Mapped IO

IO device에 메모리 주소를 맥여서 메모리 접근을 통해서 디바이스를

IO주소도 메모리에 주소에 연장되는 주소를 붙여서.. IO device에 대해서 접근하는 Instruction 넣음.

## 저장 장치 계층 구조
<img width="527" height="444" alt="스크린샷 2025-07-29 오후 10 37 44" src="https://github.com/user-attachments/assets/4cca5804-cd93-49d9-a1da-c4cdc5eae19c" />

- 위로 갈수록 속도가 빠르지만, 단위 공간당 비용이 비싸니 용량이 적다.
그래서 빠른 저장 장치 느린 저장 장치 라고도함..
- Secondary는 비휘발성 Primary는 휘발성 → 전원이 나가면 사라짐 Volatility
- 위로 갈수록 속도가 빠르지만, 단위 공간당 비용이 비싸니 용량이 적다
- Secondary는 비휘발성 Primary는 휘발성 → 전원이 나가면 사라짐 Volatility

- Primary는 CPU가 직접 접근 가능 Secondary는 접근 못함. CPU가 접근 가능하려면 바이트 단위 접근이 가능해야함.
