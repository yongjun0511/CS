### ✅ 운영 체제란?

- 운영 체제는 하드웨어 바로 위에 설치되어 사용자와 다른 모든 소프트 웨어를 연결해주는 소프트웨어 계층.
- 하드웨어 자체를 사용자가 다루는 것은 쉽지 않기 떄문에 운영체제를 꼭 탑재 시켜 주어야 한다.
- 운영 체제는 부팅과 동시에 메모리에 올라가 있어서 사용되는 것인데 이때 운영체제는 규모가 커서 모두 올라가면 메모리 낭비가 심할 것이고. 메모리에 상주하는 핵심 부분을 커널(kernal)이라고 한다.

### ✅ 운영 범위에 따른 의미

좁은 의미 : 커널 (보통 전공자 입장에서 이걸 의미함)

> 부팅 일어난 이후에 항상 메모리에 상주하는 부분

넓은 의미: 커널 + 주변 시스템 유틸리티 포함하는 개념
> 복사 붙이기도 말그대로 유틸리티 중 하나이다. 이런건 중요하지 않으니.. 메모리에 상주하지는 않는다 (유티리리티)

### ✅ 운영체제의 목적

- 자원(CPU, Memory 등등)을 효율적으로 관리. but 효율적으로만 관리하면 차별 받을 수도 있다(Starvation Problem).
  따라서 어느 정도 형평성 있는 자원 분배가 필요하다. (하드웨어 자원 뿐만 아니라 소프트웨어 자원도 관리함)
- 사용자를 소프트웨어를 편리하게 사용할 수 있는 환경을 제공
  → 여러 사람들이 하나의 컴퓨터에서 자기 프로그램만 컴퓨터에서 돌아가는 듯한. 하나의 컴을 쓰는듯한 느낌을 주는 목적 Abstract machine이 여러개지만, 물리적 컴퓨터는 하나.

> 디스크에 저장하는 것들을 대신 해주는 것도 이런 편리성을 높여준다.
- 이 밖에도 보안 기능을 담당한다.
  예를 들어 사용자가 많은 경우 다른 사용자의 메모리 영역을 참조한다 거나..다른 사용자의 사적 파일에 접근하는 경우를 제한 해야함.

### ✅ 운영 체제의 분류
### 작업수

- 단일 작업 (MS-DOS 옛날 것들..단순한건 지금도 씀) → 설계 Easy  ex) 엘리베이터
- 다중 작업 (현대의 컴퓨터는 이거라고 생각해도 됨. Unix, MS windows 등등…)

### 사용자의 수

- 단일 사용자 (단일 작업은 이걸 쓰겠죠?)
- 다중 사용자 (Unix, NT server)

### ✅ 작업 처리 방식의 종류

- 일괄 저리(batch processing) → 바로 바로 x 모아서 처리 현대 운영체제에서는 찾기 힘든..
  작업 요청의 일정량을 모아서 처리 다 처리할 때까지 기다려야함. ex) Punch Card 처리 시스템
- 시분할(time sharing) → 현대에서 사용하는 컴퓨터 그 자체 처리 능력을 일정 시간 단위로 분할하여 사용
  응답시간이 짧고 Interactive하다 ex)Unix

> Interactive 한 것은 무엇을 말하는 걸까?
> 
> 자판 치면 바로 보이는 이런 부분들을 'interactive 하다' 라고 표현함. 자판 치고 3초 뒤에 나오면 이상한겠죠..?
> 사람은 시간을 짧게 하면 Interactive하다고 인식한다.

- 실시간(Realtime OS)
  정해진 시간 안에 어떠한 일이 반드시 종료됨이 보장되어야 한다.
  ex) 원자로/공장 제어, 미사일

- Hard realtime system (경성 실시간 시스템)
  : 정확히 지키지 않으면 치명적인 결과를 초래하는..

- Soft realtime system(연성 실시간 시스템)
  : 데드라인은 있는데 크게 문제가 되지 않는 것들 ex) 영화, 멀티플레이 초당 24 프레임

영화를 보아도 실시간은 처리 방식은 적용되지 않는다. 시분할을 쓰긴함 그래서 많이 띄우면 영화 꺼질수도 있다.
but, 네비게이션 이런거는 실시간성이 필요하기 때문에 "운영체제도 어떤것을 사용해야 하는가?" 이런게 이슈가 되고 있음.

💡지금 우리가 배우는 운영 체제는 다중 사용자, 다중 작업, 그리고 시분할 방식을 사용하고 있음..!!

### ✅ 몇 가지 용어 정리

- Multitasking

여러 작업이 동시에 실행되는 상태. 엄밀히 말하면 CPU에서는 하나만 돌아가고 타임 쉐어링해서 동시에 작업되는 것 같이 보임.

- Multiprogramming

메모리에 여러가지가 올라간다. 멀티 테스킹이 될려면 당연히 그래야 하지만 메모리를 강조하는 경우 이걸씀. 멀티테스킹이랑 비슷함.

- Time sharing

이번에는 CPU를 강조한 느낌 결국 멀티테스킹과 유사

- Multiprocess

이것도 결국 유사.

⭐ Multiprocessor

processor는 일반적으로 CPU라고 하는데, CPU가 여러개인 컴퓨터를 멀티 프로세서라고 한다.

### ✅ 운영 체제 예시

### Unix(유닉스)

- 대형 컴퓨터용으로 개발 → 다중 사용자 다중 작업을 목표
- 대부분 C언어로 작성 (이걸 만들기 위해서 새로 C언어가 만들어졌다)
- 높은 이식성과 최소한의 커널 구조.
- Portability (하나의 컴에서 다른 컴으로 옮겨서 이식)이 뛰어나다.
- 기계어 집합이 달라도 이식할 수 있다. 이것 때문에 이식성이 뛰어남 (C언어는 기계어와 독립적인 언어) .
- 커널이 작아서 효율적이다
- 복잡한 시스템에 맞게 확장 용이
- 소스 코드를 공개
- 다양한 버전 ~ System V, FreeBSD, Linux

### DOS(Disk Operating System)

- 개인용으로 MS사에서 단일 작업용으로 만듬.
- 메모리 640KB로 제한 ( 하드웨어 속도가 너무 빨라서 지금은 작은 크기)

### MS Windows

- MS사의 다중 작업용 GUI 기반 운영 체제.
- 불안정성 (지금 윈도우는 그렇게 불안하지는 않는다고함..!)
- 풍부한 지원 소프트 웨어
- Plug and play 자동으로 하드웨어 인식해서 그에 맞게 설정이 된다.

---

### 운영 체제의 구조 개괄적인 구조

CPU ↔ Memory ↔ (Disk , I/O device)

1. CPU 스케줄링
- 누구에게 CPU를 주어야 하는가? → CPU 스케줄링
- 단순히 순서대로 주기에는 문제가 생긴다 ex) 앞에 무거운 것 돌아가고 있으면 키보드도 안먹음.

> ex)
선입선출 기법 - 먼저 도착한 것을 먼저 처리
CPU 자체는 효율적이지만 시스템 입장에서는 비효율

> 라운드 로빈 기법 - CPU를 한 번 할당받아 사용할 수 있는 시간을 일정하게 고정된 시간으로 제한. 

> 우선순위 스케줄링 - 우선순위를 부여하고 CPU먼저 할당.


2.  메모리 관리

- 한정된 메모리를 어떻게 잘 쪼개서 써야 하는가?
- 너무 많은 것을 올려놓으면 좋지 않다. CPU에서 원활하게 사용할 수 있을 정도만 (ex : 워킹셋 모델).
- 디스크 꽉차면 뭘 쫒아내야 하는가?
> CPU에서 사용하지 않을 법한 것들 쫒아내야지 미래는 예측해야한다.
> 
> 어떤 데이터가 메모리에서 많이 사용되고 최근에 많이 사용되었으면 메모리에서 쫒아내지 않는 느낌
과거에서 미래를 예측한다.
>
> 다른 프로세스의 영역을 침범하지 않도록 적당히 나누어 주어야함.

- 고정 분할 : 몇개의 분할을 미리 나누어 관리한다. 각 분할에 하나의 프로그램 → 융통성 x
너무 큰 프로그램은 사용하지 못하고 더 작은 프로그램을 쓰면 남는 내부조각 (internal fragmentation)이 남는다.

- 가변 분할 : 크기에 맞게 메모리를 분할
외부 조각이 생길 수 있음 (External fragmentation) 외부 조각은 프로그램 사이에 생긴 작은 조각.

- 가상 메모리 기법 - 물리적 메모리 보다 더 큰 프로그램을 지원할 수 있음.
모든 프로그램은 물리적 메모리와 독립적으로 0번지부터 시작하는 가상 메모리가 있음. 가상 메모리 주소를 물리 메모리에 매핑하는 기술을 통해 변환.

- 가상 메모리 기법 구현 - 프로그램 크기만큼을 메모리에 다 올리는게 아니라 사용되는 부분만 올려놓고 하드 디스크와 같은 보조 기억장치에 저장해 놓았다가 필요할 때 메모리에 적재함.
이때 사용되는 영역을 Swap area(스왑 영역)이라고 한다.

3. 디스크 파일 관리
- 어떻게 데이터를 보관하야 하는가?
- 디스크도 스케줄링이 필요하다. 요청들이 계속 들어오기 때문에, 헤드의 위치에 따라서 처리를 하는 방법이 존재한다.

> 엘베 사용자와 굉장히 유사한 스케줄링을 사용한다.
ex) 1층 → 100층 →2층 픽업 이렇게 하면 별로니까!!

4. I/O device
- 입출력 관리를 어떻게 할 것인가?
- I/O device는 느린데.. 이걸 CPU와 정보를 주고 받는 것을 어떻게 할 것인가?
- 이건 인터럽트에 기반해서 관리하고 있다.
→ CPU는 항상 빠르게 자기 할 일 하고 있는데 인터럽트라는 것으로 보고해서 CPU에게 요청 같은 것을 보냄. CPU가 최대한 방해 받지 않도록.

