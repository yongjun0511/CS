## 📌 프로그램의 실행 (메모리 load)

<img width="565" height="320" alt="스크린샷 2025-07-31 오후 4 15 59" src="https://github.com/user-attachments/assets/bceb3313-1c6a-4705-8324-97c72c6b6188" />

- 보통 프로그램은 실행 파일 형태로 하드 디스크에 저장이 되어 있다.
- 이걸 메모리에 올리게 되면 프로세스가 된다. 보통은 물리적 메모리에 바로 올라가지 않고 Virtual Memory를 거쳐서 올라가게 됩니다.

<img width="610" height="346" alt="스크린샷 2025-07-31 오후 4 16 37" src="https://github.com/user-attachments/assets/bdb163bd-2a8a-4fb3-a2b8-66a341671f17" />

- 어떤 프로그램을 실행시키면 Address Space 주소 공간이 생성되게 되는데 0번지 부터 시작하는 독자적인 주소 공간이 만들어지게 된다.
- 프로세스는 메모리에 다음과 같은 것들을 올려놓는다.

> code : CPU에서 실행할 기계어 코드
> 
> data : 변수, 전역 변수 프로그램이 사용하는 자료 구조
> 
> stack : 돌아가야할 코드 주소를 기록

- 가상 메모리에서 당장 필요한 것들만 물리적 메모리에 올리게 된다.
- 필요없는 것들은 없애거나 스왑에 잠시 올려놓을 수도 있고, 이걸 스왑 아웃(swap out)시킨다고 함.

- 물리적 메모리도 사실상 0번지 부터 시작하는 주소들의 집합이며, Virtual 메모리도 0번지 부터 시작하니 메모리에 올릴 때 주소를 변환해야 하고 이것을 주소 변환 이라고 한다.
- 주소 변환 계층 → 하드웨어 장치

## 📌 커널 영역 주소 공간의 내용

code ( 커널 코드)

- 시스템 콜 인터럽트 처리 코드
- 자원 관리 코드
- 편리한 서비스 제공 코드

data

- 운영 체제가 사용하는 여러 자료구조.
- CPU, memory, disk 를 위한 자료 구조도 존재한다.
- 프로그램 관리를 위한 자료 구조 → PCB (Process Control Block)
- 프로그램마다 하나씩 생김.

stack
- code는 여러 프로그램은 커널 코드 사용이 가능하다. 그런데, 그렇다면 커널 주소로 복귀를 해야하기 때문에 별도로 프로그램마다 커널 스택을 따로 가지고 있다.
- 자기 자신의 코드 내의 복귀 주소가 필요한 경우 자기 주소 공간의 스택을 사용하고,
- 시스템 콜이나 인터럽트트 등으로 운영체제의 코드가 실행되는 중에 함수 호출이 발생하면 커널 스택을 사용함.

## 📌 사용자 프로그램이 사용하는 함수

- 모든 프로그램은 함수로 만들어져 있음.
1. 사용자 정의 함수
- 자신이 정의한 함수

2. 라이브러리 함수
- 누가 만들어 놓은 유용한 함수들 .

3. 커널 함수
- 운영체제 프로그램의 함수
- 시스템 콜을 통해서 가져다 쓸 수 있다.
- 일반 함수에서는 커널 함수를 바로 호출 못하니 시스템 콜을 통해서 사용하며, 인터럽트 라인 세팅 후 실행한다.
  
<img width="512" height="297" alt="스크린샷 2025-07-31 오후 4 22 26" src="https://github.com/user-attachments/assets/e6c5de72-0734-44e1-bf9a-21e54b7fe39f" />

- 라이브러리 함수 같은 것은 본인의 주소 공간에서 실행.
- A프로세스가 커널 공간에서 작업중일 때에도 여전히 A프로세스는 실행중이며 커널영역에서 A프로세스가 실행중이라고 말함.

## 📌 PCB와 Conetext 저장의 사이클에 대한 인사이트

> 특정 프로세스 A에 대해서 생각해보자.

- 프로세스의 메모리 영역에 존재하는 것 : A의 프로세스 stack 
- 커널 영역에 존재하는 것 : A의 PCB , A의 커널 스택

> 현재 작업으로 복귀했을 때 (RR에 의해서) 현재 프로세스의 작업 정보를 어떻게 알 수 있을까요?

- PCB에는 현재 프로세스가 실행하는 위치(PC)에 대해서 기록하고 있다.
- PC가 커널 영역을 가르키고 있다면 커널 영역에서 작업중이고 프로세스 메모리를 가르킨다면 프로세스 영역에서 작업중이다.
- 이때, 현재 포인터가 프로세스를 가르킨다면 stack 또한 A의 프로세스 스택을 가르키며, 현재 포인터가 커널 영역을 가르킨다면 stack 또한 A의 커널 스택을 가르키고 있을 것이다.

따라서, PCB는 프로세스가 마지막에 어떤 모드였는지를 파악할 수 있는 수단이다.

> PCB는 언제 갱신이 되며, 커널 모드 진입과 문맥 교환의 차이

- PCB는 항상 갱신이 되는 것이 아니고 문맥 교환이 일어나는 경우 업데이트 된다.
- 문맥 교환과 커널 모드 진입은 다르다.

ex) 커널에 진입하는 경우
- CPU의 레지스터 (PC, SP 등)는 바뀝니다
- 커널 스택에 현재 유저 모드의 컨텍스트가 저장됩니다 (자동/수동 push)
- 그러나 PCB는 건드리지 않는다.

ex) 문맥 교환을 하는 경우
- 현재 실행 중인 프로세스의 컨텍스트(레지스터, PC, SP 등)를 PCB에 저장한다.
- 커널은 스케줄러를 통해 다음에 실행할 프로세스를 선택한다.
- 선택된 프로세스의 PCB에서 컨텍스트 정보를 복원한다.
- 복원된 컨텍스트에 따라 CPU 레지스터와 스택 포인터를 설정한다.
- 선택된 프로세스의 실행을 재개한다.


